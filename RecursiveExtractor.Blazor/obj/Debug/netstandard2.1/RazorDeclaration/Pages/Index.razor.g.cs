#pragma checksum "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/Pages/Index.razor" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "58ad1f7e5b8eb69446f235f1ccd831731efc525a"
// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace RecursiveExtractor.Blazor.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#nullable restore
#line 1 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using System.Net.Http;

#line default
#line hidden
#nullable disable
#nullable restore
#line 2 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using System.Net.Http.Json;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using Microsoft.AspNetCore.Components.Forms;

#line default
#line hidden
#nullable disable
#nullable restore
#line 4 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using Microsoft.AspNetCore.Components.Routing;

#line default
#line hidden
#nullable disable
#nullable restore
#line 5 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using Microsoft.AspNetCore.Components.Web;

#line default
#line hidden
#nullable disable
#nullable restore
#line 6 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using Microsoft.AspNetCore.Components.WebAssembly.Http;

#line default
#line hidden
#nullable disable
#nullable restore
#line 7 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/_Imports.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#nullable disable
#nullable restore
#line 2 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/Pages/Index.razor"
using System.IO;

#line default
#line hidden
#nullable disable
#nullable restore
#line 3 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/Pages/Index.razor"
using System.Diagnostics;

#line default
#line hidden
#nullable disable
#nullable restore
#line 4 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/Pages/Index.razor"
using Tewr.Blazor.FileReader;

#line default
#line hidden
#nullable disable
#nullable restore
#line 5 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/Pages/Index.razor"
using Microsoft.CST.RecursiveExtractor;

#line default
#line hidden
#nullable disable
    [Microsoft.AspNetCore.Components.RouteAttribute("/")]
    public partial class Index : Microsoft.AspNetCore.Components.ComponentBase
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.Rendering.RenderTreeBuilder __builder)
        {
        }
        #pragma warning restore 1998
#nullable restore
#line 22 "/Users/gabe/Documents/GitHub/RecursiveExtractor/RecursiveExtractor.Blazor/Pages/Index.razor"
 
    private static string nl = Environment.NewLine;
    [Parameter]
    public int BufferSize { get; set; } = 20480;
    public long max;
    public long value;
    ElementReference inputElement;
    public System.Threading.CancellationTokenSource? cancellationTokenSource;
    string Output { get; set; } = string.Empty;

    public bool CanCancel { get; set; }
    public bool IsCancelDisabled => !CanCancel;
    Extractor extractor = new Extractor();

    public async Task ClearFile()
    {
        await fileReaderService.CreateReference(inputElement).ClearValue();
    }

    public async Task ReadFile()
    {
        var fileEntries = new List<FileEntry>();

        max = 0;
        value = 0;
        Output = string.Empty;
        this.StateHasChanged();
        var files = await fileReaderService.CreateReference(inputElement).EnumerateFilesAsync();
        foreach (var file in files)
        {
            var fileInfo = await file.ReadFileInfoAsync();
            max = fileInfo.Size;

            var stopwatch = new Stopwatch();
            stopwatch.Start();
            Output += $"Reading file..."+nl;
            this.StateHasChanged();
            Console.WriteLine(Output);
            cancellationTokenSource?.Dispose();
            cancellationTokenSource = new System.Threading.CancellationTokenSource();
            CanCancel = true;

            const int onlyReportProgressAfterThisPercentDelta = 10;

            // Subscribe to progress (change of position)
            fileInfo.PositionInfo.PositionChanged += (s, e) =>
            {
                // (optional) Only report progress in console / progress bar if percentage has moved over 10% since last call to Acknowledge()
                if (e.PercentageDeltaSinceAcknowledge > onlyReportProgressAfterThisPercentDelta)
                {
                    stopwatch.Stop();
                    Output += $"Read {(e.PositionDeltaSinceAcknowledge)} bytes ({e.Percentage:00}%). {e.Position} / {fileInfo.Size}{nl}";
                    this.InvokeAsync(this.StateHasChanged);
                    e.Acknowledge();
                    value = e.Position;
                    stopwatch.Start();
                }
            };

            try
            {
                using var stream = await file.OpenReadAsync();
                using var fileStream = new FileStream(Path.GetTempFileName(), FileMode.Open, FileAccess.ReadWrite, FileShare.Read, 4096, FileOptions.DeleteOnClose);
                await stream.CopyToAsync(fileStream);
                var streamEntries = extractor.ExtractStream(fileInfo.Name, fileStream, new ExtractorOptions() { Parallel = false, ExtractSelfOnFail = false, EnableTiming = false });
                foreach(var entry in streamEntries)
                {
                    appData.GuidToFileEntryMap[Guid.NewGuid().ToString()] = entry;
                }
            }
            catch (OperationCanceledException)
            {
                Output += $"Operation was cancelled";
                await InvokeAsync(StateHasChanged);
                await Task.Delay(1);
            }
            catch (Exception e)
            {
                var message = e.Message;
                var stackTrace = e.StackTrace;
                var type = e.GetType();
                var name = type.Name;
                type = e.GetType();
            }
            finally
            {
                CanCancel = false;
            }
            value = max;
            Output += $"Done reading file {fileInfo.Name} - {fileInfo.Size} bytes in {stopwatch.ElapsedMilliseconds}ms.{nl}.";
            await InvokeAsync(StateHasChanged);
        }
    }

    public async Task CancelFile()
    {
        Output += $"Cancel requested.{nl}";
        await InvokeAsync(StateHasChanged);
        await Task.Delay(1);
        cancellationTokenSource.Cancel();
    }

#line default
#line hidden
#nullable disable
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private RecursiveExtractor.Blazor.Services.AppData appData { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private Blazored.LocalStorage.ILocalStorageService localStorage { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IFileReaderService fileReaderService { get; set; }
    }
}
#pragma warning restore 1591
